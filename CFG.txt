----------START----------
<program> -> <global_decl_list>
	//Program consists of variable and function declarations.
	//There must be a main function, but that's not for the CFG to determine.
<global_decl_list> -> <global_decl_list> <global_decl> | e
<global_decl> -> <decl_list> <function_decl_list>

----------DECLARATIONS----------
<function_decl_list> -> <function_decl> <function_decl_list> | e
<function_decl> -> <type> ID (<parameter_list>) {<block>}

<parameter_list> -> <type> ID <param_bracket_chain> <parameter_list> | e
	//<param_bracket_chain> accounts for all the possible array dimensions, and allows the first row dimension to be empty

<param_bracket_chain> -> [] <bracket_chain> | <bracket_chain> | e

<block> -> <decl_list> <statement_list> | e

<decl_list> -> <decl> <decl_list> | e
<decl> -> <type> ID <bracket_chain>| <type> <id_list> | <struct_def> | TYPEDEF <type> ID

<bracket_chain> -> [INT] <bracket_chain> | e
	//<bracket_chain> accounts for all the possible array dimensions. All dimensions must be filled.

<id_list> -> ID <id tail>
<id_tail> -> ID <id tail> | e

<type> -> INT | FLOAT | STRUCT ID | ID | VOID

-----STRUCT-----
<struct_def> -> STRUCT ID {<struct_block>}; | TYPEDEF STRUCT ID {<struct_block>} ID;

<struct_block> -> <type> ID <struct_block_tail>
<struct_block_tail> -> <type> ID <struct_block_tail> | e

----------STATEMENTS----------
<statement_list> -> <statement> <statement_tail>
<statement_tail> -> <statement> <statement_tail> | e
<statement> -> <expression> | ID OP_ASSIGN <expression> | <control_stmt> | RETURN | RETURN <expression>
	//TODO: Double check if an expression with no assignment is still a syntatically correct statement.

----------EXPRESSIONS---------
//Order of operations goes parenthesis -> mul/div -> add/sub -> gt/lt/ge/le/eq/ne -> and -> or

<function_call> -> ID (<expr_list>)

<expr_list> -> <expression> <expr_tail>
<expr_tail> -> <expression> <expr_tail> | e

//Expression tree encoded with order of operations
<expression> -> <expression> OP_OR <and_op_res> | <and_op_res> | <function_call>
<and_op_res> -> <and_op_res> OP_AND <comp_op_res> | <comp_op_res>
<comp_op_res> -> <comp_op_res> <comp_op> <add_op_res> | <add_op_res>
<add_op_res> -> <add_op_res> <add_op> <mul_op_res> | <mul_op_res>
<mul_op_res> -> <mul_op_res> <mul_op> <factor> | <factor>
<factor> -> INT | FLOAT | ID | (<expression>) | <function_call>

<add_op> -> OP_PLUS | OP_MINUS
<mul_op> -> OP_TIMES | OP_DIVIDE
<comp_op> -> OP_EQ | OP_NE | OP_LT | OP_GT | OP_LE | OP_GE
----------CONTROL STATEMENTS----------
<control_stmt> -> <if_stmt> | <for_stmt> | <while_stmt>

<if_stmt> -> IF (<expression>) {<block>} <if_tail>
<if_tail> -> ELSE {<block>} | e

<for_stmt> -> FOR (<expression>, <expression>, <expression>) {<block>}

<while_stmtmt> -> WHILE (<expression>) {<block>}